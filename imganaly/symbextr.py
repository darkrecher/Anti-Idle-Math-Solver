# -*- coding: utf-8 -*-"""créé par Réchèr. Licence CC-BY ou Art Libre.https://github.com/darkrecher/Anti-Idle-Math-Solverje prends les bitcoins : 12wF4PWLeVAoaU1ozD1cnQprSiKr6dYW1GModule contenant la classe SymbolExtractor, qui extrait les symboles et le gros opérateur d'une zone d'énigme, et qui permet également de savoir si une nouvelle énigme s'est affichée dans la zone.Mode d'emploi=============Extraction de symboles----------------------Instancier un SymbolExtractor.Exécuter la fonction extract_symbols_data, en passant en paramètre le dc de lazone d'énigme, et ses dimensions width et height. (voir module gamedtc.py et enizodtc.py pour détecter une zone d'énigme). La fonction va tenter de détecter l'éventuelle présence du gros opérateur, ainsi que les dessins de symbole situés avant et après. Les dessins de symbole se récupèrent  sous la forme de "raw_symbol" (tableaux brut, en 2D, de valeurs d'encre). On pourra créer des objets Symbole à partir de ces tableaux bruts (voir module symbole.py).Après l'appel à extract_symbols_data, le résultat est placé dans les 3 variables membres suivantes : - list_raw_symbols_before : raw_symbol trouvés avant le gros opérateur. - rgb_big_op : trouple de valeur (red, green, blue), correspondant à la    couleur de fond du gros opérateur. (on ne récupère pas le symbole du gros   opérateur, car y'en n'a pas besoin). - list_raw_symbols_after : raw_symbol trouvés après le gros opérateur.Si la zone d'énigme ne contient pas de gros opérateur, la variables rgb_big_opvaut None, et list_raw_symbols_after vaut une chaîne vide. Tous les symbolestrouvés sont dans list_raw_symbols_before.Détection de changements dans la zone d'énigme----------------------------------------------Après avoir instancié un SymbolExtractor et exécuté une première fois la fonction extract_symbols_data, la classe conserve en mémoire le dc qu'on luia passé en paramètre.On peut alors exécuter la fonction is_new_image, en passant en paramètre unenouvelle capture d'écran de la zone d'énigme. (Pas besoin de redonner lesdimensions, on garde celles indiqués lors de l'exécution de extract_symbols_data). La fonction cherche si il y a eu un quelconque changement dans les pixels, entre la zone d'énigme utilisée lors de la détection de symbole, et la nouvelle zone d'énigme passée en paramètre. Ellerenvoie un booléen. True : il y a eu un changement, False, y'en n'a pas eu.Fonctionnement interne====================== """from log import logclass SymbolExtractor():    """     """        # TODO : factoriser ça    RGB_EXACT_ENIGMA_ZONE = (0, 0, 102)        def __init__(self):        pass            # TODO : la taille change jamais. Faut la donner une seule fois au début.    def extract_symbols_data(self, dc_enigma_zone, x_size_ez, y_size_ez):        """ crée des symboles "raw". C'est à dire qu'il peut y avoir des         lignes vides au dessus et en dessous."""        self.x_size_ez = x_size_ez        self.y_size_ez = y_size_ez        self.dc_enigma_zone = dc_enigma_zone        # colonne, dans le dc d'une enigma zone, à partir de laquelle est         # dessiné le gros opérateur. (peut rester None si pas de gros        # opérateur dans l'énigme).        self.x_big_op_start = None        # colonne, dans le dc d'une enigma zone, jusqu'à laquelle est         # dessiné le gros opérateur. (peut aussi rester None).        self.x_big_op_end = None        self.rgb_big_op = None        # liste des symboles présents avant le gros opérateur.        self.list_raw_symbols_before = []        # liste des symboles présents après le gros opérateur. (reste vide        # si pas de gros opérateur dans l'énigme).        self.list_raw_symbols_after = []        self.x_first_interesting_column = None                self._detect_big_op()        log(self.x_big_op_start, self.x_big_op_end, self.rgb_big_op)        if self.rgb_big_op is not None:            list_columord_symbols_before = self._extract_columord_symbols(                0, self.x_big_op_start)            list_columord_symbols_after = self._extract_columord_symbols(                self.x_big_op_end+1, self.x_size_ez)        else:            list_columord_symbols_before = self._extract_columord_symbols(                0, self.x_size_ez)            list_columord_symbols_after = []                    # réordonnancement des valeurs d'ink, dans les symboles.         # Au lieu qu'ils soient par colonne, on les met par lignes.        self.list_raw_symbols_before = [             zip(*columord_symb)             for columord_symb in list_columord_symbols_before ]        self.list_raw_symbols_after = [             zip(*columord_symb)             for columord_symb in list_columord_symbols_after ]            # TODO : n'a pas grand chose à faire là. Ça devrait être dans     # une classe dédiée. (avec des step X et Y configurables)    def is_new_image(self, dc_refreshed):        for x in xrange(self.x_first_interesting_column, self.x_size_ez, 3):            for y in xrange(0, self.y_size_ez, 2):                rgb_refreshed = dc_refreshed.GetPixel(x, y)[0:3]                rgb_cur = self._get_pixel(x, y)                if rgb_refreshed != rgb_cur:                    return True        # TODO : vilain copier-coller        for x in xrange(self.x_first_interesting_column, 0, -3):            for y in xrange(0, self.y_size_ez, 2):                rgb_refreshed = dc_refreshed.GetPixel(x, y)[0:3]                rgb_cur = self._get_pixel(x, y)                if rgb_refreshed != rgb_cur:                    return True                return False            # TODO : factoriser ça avec les autres classes.    def _get_pixel(self, x, y):        return self.dc_enigma_zone.GetPixel(x, y)[0:3]            # TODO : factoriser ça aussi.    def _is_pixel_interesting(self, x, y):        (red, grn, blu) = self._get_pixel(x, y)        return red > 100 and red == grn        def _get_ink_of_pixel(self, x, y):        (red, grn, blu) = self._get_pixel(x, y)        # Attention, c'est pas tout à fait pareil que _is_pixel_interesting.        # On vérifie pas si c'est plus de 100.         if red == grn:            return red        else:            return 0        def _get_column_ink(self, x):        return [             self._get_ink_of_pixel(x, y_cur)             for y_cur in xrange(0, self.y_size_ez) ]        # TODO : une classe commune SymbolExtractor + EnigmaZoneDetector    # Avec ces fonctions de base dedans.    def _is_column_interesting(self, x):        return any(             ( self._is_pixel_interesting(x, y)               for y in range(self.y_size_ez) ) )            def is_rgb_big_op(self, rgb):        return all( ( comp_rgb in (76, 140) for comp_rgb in rgb) )            # TODO : fonction générique find_first ?     # on recule/avance sur une ligne/colonne, jusqu'à rencontrer un pixel     # qui correspond à une condition, passée en paramètre.    def _detect_big_op(self):        y = self.y_size_ez / 2        # TODO : renommer x_cur en x_cursor.        x_cur = 0        # Putain, pourquoi y'a pas de repeat until comme en Pascal ?         # C'était cool ce truc.        while True:            rgb_cur = self._get_pixel(x_cur, 0)            if self.is_rgb_big_op(rgb_cur):                break            x_cur += 1            if x_cur >= self.x_size_ez:                return False                self.rgb_big_op = rgb_cur        x_rgb_big_op = x_cur        while self._get_pixel(x_cur, 0) != self.RGB_EXACT_ENIGMA_ZONE:            x_cur -= 1        self.x_big_op_start = x_cur + 1        x_cur = x_rgb_big_op         while self._get_pixel(x_cur, 0) != self.RGB_EXACT_ENIGMA_ZONE:            x_cur += 1        self.x_big_op_end = x_cur - 1        return True        def _extract_columord_symbols(self, x_start, x_end):        """ columord symbols = column ordered symbols.        C'est à dire : les symboles, dont les encres sont rangées par colonne.        """        # bourrin. On checke tous les pixels. On stock au fur et à mesure.        # TRIP: j'ai toujours trouvé bizarre ce mot : "fur". D'où il vient ?        list_column_inks_of_current_symbol = []        list_columord_symbols = []        inside_symbol = False                for x_cur in xrange(x_start, x_end):            if self._is_column_interesting(x_cur):                if self.x_first_interesting_column is None:                    self.x_first_interesting_column = x_cur                inside_symbol = True                column_ink = self._get_column_ink(x_cur)                list_column_inks_of_current_symbol.append(column_ink)            else:                if inside_symbol:                    list_columord_symbols.append(                        list_column_inks_of_current_symbol)                    list_column_inks_of_current_symbol = []                    inside_symbol = False                            if inside_symbol:            list_columord_symbols.append(                list_column_inks_of_current_symbol)                        return list_columord_symbols                