# -*- coding: utf-8 -*-from log import logclass SymbolExtractor():    """     """        # TODO : factoriser ça    RGB_EXACT_ENIGMA_ZONE = (0, 0, 102)        def __init__(self):        pass            def extract_symbols_data(self, dc_enigma_zone, x_size_ez, y_size_ez):        """ crée des symboles "raw". C'est à dire qu'il peut y avoir des         lignes vides au dessus et en dessous."""        self.x_size_ez = x_size_ez        self.y_size_ez = y_size_ez        self.dc_enigma_zone = dc_enigma_zone        self.x_big_op_start = None        self.x_big_op_end = None        self.rgb_big_op = None        self.list_raw_symbols_before = None        self.list_raw_symbols_after = None        self.x_first_interesting_column = None                self._detect_big_op()        log(self.x_big_op_start, self.x_big_op_end, self.rgb_big_op)        if self.rgb_big_op is not None:            list_columord_symbols_before = self._extract_columord_symbols(                0, self.x_big_op_start)            list_columord_symbols_after = self._extract_columord_symbols(                self.x_big_op_end+1, self.x_size_ez)        else:            list_columord_symbols_before = self._extract_columord_symbols(                0, self.x_size_ez)            list_columord_symbols_after = []                    # réordonnancement des valeurs d'ink, dans les symboles.         # Au lieu qu'ils soient par colonne, on les met par lignes.        self.list_raw_symbols_before = [             zip(*columord_symb)             for columord_symb in list_columord_symbols_before ]        self.list_raw_symbols_after = [             zip(*columord_symb)             for columord_symb in list_columord_symbols_after ]                    # TODO : factoriser ça avec les autres classes.    def _get_pixel(self, x, y):        return self.dc_enigma_zone.GetPixel(x, y)[0:3]            # TODO : factoriser ça aussi.    def _is_pixel_interesting(self, x, y):        (red, grn, blu) = self._get_pixel(x, y)        return red > 100 and red == grn        def _get_ink_of_pixel(self, x, y):        (red, grn, blu) = self._get_pixel(x, y)        # Attention, c'est pas tout à fait pareil que _is_pixel_interesting.        # On vérifie pas si c'est plus de 100.         if red == grn:            return red        else:            return 0        def _get_column_ink(self, x):        return [             self._get_ink_of_pixel(x, y_cur)             for y_cur in xrange(0, self.y_size_ez) ]        # TODO : une classe commune SymbolExtractor + EnigmaZoneDetector    # Avec ces fonctions de base dedans.    def _is_column_interesting(self, x):        return any(             ( self._is_pixel_interesting(x, y)               for y in range(self.y_size_ez) ) )            def is_rgb_big_op(self, rgb):        return all( ( comp_rgb in (76, 140) for comp_rgb in rgb) )            # TODO : fonction générique find_first ?     # on recule/avance sur une ligne/colonne, jusqu'à rencontrer un pixel     # qui correspond à une condition, passée en paramètre.    def _detect_big_op(self):        y = self.y_size_ez / 2        x_cur = 0        # Putain, pourquoi y'a pas de repeat until comme en Pascal ?         # C'était cool ce truc.        while True:            rgb_cur = self._get_pixel(x_cur, 0)            if self.is_rgb_big_op(rgb_cur):                break            x_cur += 1            if x_cur >= self.x_size_ez:                return False                self.rgb_big_op = rgb_cur        x_rgb_big_op = x_cur        while self._get_pixel(x_cur, 0) != self.RGB_EXACT_ENIGMA_ZONE:            x_cur -= 1        self.x_big_op_start = x_cur + 1        x_cur = x_rgb_big_op         while self._get_pixel(x_cur, 0) != self.RGB_EXACT_ENIGMA_ZONE:            x_cur += 1        self.x_big_op_end = x_cur - 1        return True        def _extract_columord_symbols(self, x_start, x_end):        """ columord symbols = column ordered symbols.        C'est à dire : les symboles, dont les encres sont rangées par colonne.        """        # bourrin. On checke tous les pixels. On stock au fur et à mesure.        # TRIP: j'ai toujours trouvé bizarre ce mot : "fur". D'où il vient ?        list_column_inks_of_current_symbol = []        list_columord_symbols = []        inside_symbol = False                for x_cur in xrange(x_start, x_end):            if self._is_column_interesting(x_cur):                if self.x_first_interesting_column is None:                    self.x_first_interesting_column = x_cur                inside_symbol = True                column_ink = self._get_column_ink(x_cur)                list_column_inks_of_current_symbol.append(column_ink)            else:                if inside_symbol:                    list_columord_symbols.append(                        list_column_inks_of_current_symbol)                    list_column_inks_of_current_symbol = []                    inside_symbol = False                            if inside_symbol:            list_columord_symbols.append(                list_column_inks_of_current_symbol)                        return list_columord_symbols                