# -*- coding: utf-8 -*-from log import log, msgfrom symbol import Symbolfrom symbref import SymbolReferencesclass EnigmaOcr():    """Ouais bon, c'est pas du tout de l'OCR, mais fallait bien que je trouve    un nom. non de non."""        DICT_OPERATOR_FROM_EXACT_RGB = {        (76, 140, 76) : "+",        (140, 76, 76) : "-",        (140, 140, 76) : "*",        (76, 76, 140) : "/",    }        def __init__(self):        self.symbole_references = SymbolReferences()                def ocr_ify_enigma(self, list_symbol_before, rgb_big_op, list_symbol_after):        #for symb in list_symbol_before:        #    log(symb)        #log(rgb_big_op)        #for symb in list_symbol_after:        #    log(symb)        self.list_symbol = []        self.list_signifiance = []                list_signifiance_before = [             self.symbole_references.find_signifiance(symb)            for symb in list_symbol_before ]        self.list_symbol.extend(list_symbol_before)        self.list_signifiance.extend(list_signifiance_before)                if rgb_big_op is not None:            # osef, c'est juste pour avoir list_symbol et list_signifiance            # cohérentes entre elles.            symb_big_op = Symbol()             signifiance_big_op = self.DICT_OPERATOR_FROM_EXACT_RGB.get(                rgb_big_op,                 "!")            self.list_symbol.append(symb_big_op)            self.list_signifiance.append(signifiance_big_op)                list_signifiance_after = [             self.symbole_references.find_signifiance(symb)            for symb in list_symbol_after ]        self.list_symbol.extend(list_symbol_after)        self.list_signifiance.extend(list_signifiance_after)                self.enigma_text = "".join(self.list_signifiance)        return "!" not in self.enigma_text                def record_enigma_text_complete(self, enigma_text_help):        # TODO : expliquer ce bordel en détail, car c'est pas si simple.        if len(enigma_text_help) == len(self.enigma_text):            list_symb_and_sig_and_sig_help = zip(                self.list_symbol,                 self.list_signifiance,                 list(enigma_text_help))            list_symb_and_sig_help = [                (symb, sig_help)                 for (symb, sig_cur, sig_help)                 in list_symb_and_sig_and_sig_help                if sig_cur == "!" ]        else:            list_symb_and_sig = zip(self.list_symbol, self.list_signifiance)            # TODO : foutre ce point d'exclamation en constante globale.            list_symb_and_sig_unknown = [                 symb_and_sig for symb_and_sig in list_symb_and_sig                 if symb_and_sig[1] == "!" ]            if len(list_symb_and_sig_unknown) != len(enigma_text_help):                msg("nb de car different du nb de symb qu'il faut determiner")                return            list_symb_and_sig_help = [                (symb, sig_help)                 for ( (symb, sig_unknown), sig_help )                in zip(list_symb_and_sig_unknown, list(enigma_text_help)) ]                for (symb, sig_help) in list_symb_and_sig_help:            if sig_help not in "0123456789/*-+=?x(),":                msg("caractere incorrect dans la saisie : ", sig_help)            else:                if sig_help == "x":                    sig_help = "*"                symb.assign_signifiance(sig_help)                self.symbole_references.add_reference(symb)            