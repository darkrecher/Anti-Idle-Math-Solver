# -*- coding: utf-8 -*-""" créé par Réchèr. Licence CC-BY ou Art Libre.https://github.com/darkrecher/Anti-Idle-Math-Solverje prends les bitcoins : 12wF4PWLeVAoaU1ozD1cnQprSiKr6dYW1GModule contenant la classe EnigmaOcr, qui tente de reconnaître les symboles etle gros opérateur trouvés dans une zone d'énigme, afin d'en déduire le texte de l'énigme.Mode d'emploi=============Instancier une classe EnigmaOcr.Exécuter la fonction ocr_ify_enigma, en indiquant les paramètres requis  - listes des symboles situés avant le gros opérateur. - RGB de la couleur de fond du gros opérateur. (None si pas de gros op.) - listes des symboles situés après le gros opérateur. (liste vide si pas de   gros opérateur)Les listes de symboles peuvent être créés à partir des listes de "raw_symbol",qui sont renvoyés par la classe SymbolExtractor. (voir module symbextr.py).La fonction renvoie True ou False. Et on peut récupérer la valeur de lavariable membre "enigma_text", qui contient le texte de l'énigme déduit.Si la fonction a renvoyé True, enigma_text ne comportent aucun point d'exclamation, l'énigme est solvable immédiatement. Si la fonction a renvoyé False, il faudra trouver une aide extérieure pour remplacer les points d'exclamation par les vrais symboles de l'énigme, qui sont affichés à l'écran mais qu'on n'a pas pu reconnaître. En général, l'aide extérieur, c'est le joueur, mais si c'est autre chose (TRIP: un bœuf musqué, une salade, ...) c'est bien aussi.Si on a un texte d'énigme avec des points d'exclamation, et qu'on a trouvéune aide extérieure, on peut appeler la fonction record_enigma_text_complete.Le paramètre à passer à cette fonction peut être de deux formes différentes :1) une chaîne de caractère, de longueur égale au texte de l'énigme, pointd'exclamation compris. Exemple : texte d'énigme : (8+!)*!=?          texte d'aide   : (8+5)*3=?La fonction fait la correspondance 5 <=> 1er point d'exclamation, et 3 <=> 2ème. Il ajoute ces nouveaux symboles dans sa bibliothèque.Les autres caractères du texte d'aide ne sont pas utilisés. Si ils ne sontpas égaux au texte d'énigme, ça ne fait rien. Aucun contrôle n'est fait avec.2) une chaîne de caractère, avec autant de caractère qu'il y a de points d'exclamation dans le texte d'énigme.Exemple : texte d'énigme : (8+!)*!=?          texte d'aide   : 53Si on n'est dans aucun de ces 2 cas, la fonction ne fait rien.La fonction ne renvoie aucune valeur. Elle se contente d'ajouter (ou pas) dessymboles dans sa bibliothèque. Si on veut vérifier si ça a marché, il fautre-exécuter la fonction ocr_ify_enigma, avec les mêmes paramètre que la 1èrefois. Les ajouts dans la bibliothèque devraient permettre, cette fois-ci, de trouver la signifiance de tous les symboles.Si le texte d'aide passé en paramètre à record_enigma_text_complete ne contient pas les bons symboles à la place des points d'exclamation, on ne peutpas le détecter. On se retrouve avec des symboles erronés dans la bibliothèque, et la suite du fonctionnement du script n'est pas garantie."""from log import log, msgfrom symbol import Symbolfrom symbref import SymbolReferencesclass EnigmaOcr():    """Ouais bon, c'est pas du tout de l'OCR, mais fallait bien que je trouve    un nom. non de non."""        DICT_OPERATOR_FROM_EXACT_RGB = {        (76, 140, 76) : "+",        (140, 76, 76) : "-",        (140, 140, 76) : "*",        (76, 76, 140) : "/",    }        def __init__(self):        self.symbole_references = SymbolReferences()                def ocr_ify_enigma(self, list_symbol_before, rgb_big_op, list_symbol_after):        self.list_symbol = []        self.list_signifiance = []                list_signifiance_before = [             self.symbole_references.find_signifiance(symb)            for symb in list_symbol_before ]        self.list_symbol.extend(list_symbol_before)        self.list_signifiance.extend(list_signifiance_before)                if rgb_big_op is not None:            # osef, c'est juste pour avoir list_symbol et list_signifiance            # cohérentes entre elles.            symb_big_op = Symbol()             signifiance_big_op = self.DICT_OPERATOR_FROM_EXACT_RGB.get(                rgb_big_op,                 "!")            self.list_symbol.append(symb_big_op)            self.list_signifiance.append(signifiance_big_op)                list_signifiance_after = [             self.symbole_references.find_signifiance(symb)            for symb in list_symbol_after ]        self.list_symbol.extend(list_symbol_after)        self.list_signifiance.extend(list_signifiance_after)                self.enigma_text = "".join(self.list_signifiance)        return "!" not in self.enigma_text        # TODO : le nom de cette fonction est pas très bien choisi.        # TODO : renvoyer True/False pour dire si tout s'est bien passé ou pas.    def record_enigma_text_complete(self, enigma_text_help):        # TODO : expliquer ce bordel en détail, car c'est pas si simple.        if len(enigma_text_help) == len(self.enigma_text):            list_symb_and_sig_and_sig_help = zip(                self.list_symbol,                 self.list_signifiance,                 list(enigma_text_help))            list_symb_and_sig_help = [                (symb, sig_help)                 for (symb, sig_cur, sig_help)                 in list_symb_and_sig_and_sig_help                if sig_cur == "!" ]        else:            list_symb_and_sig = zip(self.list_symbol, self.list_signifiance)            # TODO : foutre ce point d'exclamation en constante globale.            list_symb_and_sig_unknown = [                 symb_and_sig for symb_and_sig in list_symb_and_sig                 if symb_and_sig[1] == "!" ]            if len(list_symb_and_sig_unknown) != len(enigma_text_help):                msg("nb de car different du nb de symb qu'il faut determiner")                return            list_symb_and_sig_help = [                (symb, sig_help)                 for ( (symb, sig_unknown), sig_help )                in zip(list_symb_and_sig_unknown, list(enigma_text_help)) ]                for (symb, sig_help) in list_symb_and_sig_help:            if sig_help not in "0123456789/*-+=?x(),":                msg("caractere incorrect dans la saisie : ", sig_help)            else:                if sig_help == "x":                    sig_help = "*"                symb.assign_signifiance(sig_help)                self.symbole_references.add_reference(symb)            